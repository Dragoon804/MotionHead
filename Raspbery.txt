import cv2
import serial
import time

# --- КОНФИГУРАЦИЯ ---
SERIAL_PORT = '/dev/ttyACM0'  # Убедитесь, что это правильный порт
BAUD_RATE = 9600
CASCADE_PATH = "/home/raspbery/Downloads/haarcascade_frontalface_alt2.xml"

FRAME_WIDTH = 640
FRAME_HEIGHT = 480
DESIRED_FPS = 10  # Стабильная частота кадров
FRAME_DELAY = 1.0 / DESIRED_FPS

# --- ИНИЦИАЛИЗАЦИЯ ---
try:
    ser = serial.Serial(SERIAL_PORT, BAUD_RATE, timeout=1)
    time.sleep(2)  # Ждем инициализации порта
    print(f"Подключен к {SERIAL_PORT}")
except serial.SerialException as e:
    print(f"Ошибка подключения к порту {SERIAL_PORT}: {e}")
    exit()

face_cascade = cv2.CascadeClassifier(CASCADE_PATH)
if face_cascade.empty():
    print(f"Ошибка: Не удалось загрузить классификатор Хаара из {CASCADE_PATH}.")
    ser.close()
    exit()

cap = cv2.VideoCapture(0)
cap.set(cv2.CAP_PROP_FRAME_WIDTH, FRAME_WIDTH)
cap.set(cv2.CAP_PROP_FRAME_HEIGHT, FRAME_HEIGHT)

# --- ОСНОВНЫЕ ПЕРЕМЕННЫЕ ---
last_face_detected_time = time.time()  # Время последнего обнаружения лица
FACE_TIMEOUT = 30.0  # 30 секунд

try:
    while True:
        start_time = time.time()
        ret, img = cap.read()
        if not ret:
            print("Ошибка захвата кадра")
            break

        # Обработка изображения
        img_gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
        faces = face_cascade.detectMultiScale(img_gray, scaleFactor=1.1, minNeighbors=4)
        
        # Определяем самое большое лицо
        largest_face = None
        if len(faces) > 0:
            largest_face = max(faces, key=lambda f: f[2] * f[3])
        
        face_detected = largest_face is not None

        if face_detected:
            # Обновляем время последнего обнаружения лица
            last_face_detected_time = time.time()
            
            x, y, w, h = largest_face
            center_x = x + w // 2
            center_y = y + h // 2

            # Рисуем точку центра лица
            cv2.circle(img, (center_x, center_y), 5, (0, 0, 255), -1)
            
            # Рисуем прямоугольник вокруг лица
            cv2.rectangle(img, (x, y), (x + w, y + h), (0, 255, 0), 2)
            
            # Определяем секторы (простое деление на 3 части)
            sector_x = center_x // (FRAME_WIDTH // 3)
            sector_y = center_y // (FRAME_HEIGHT // 3)
            
            # Логика приоритета X -> Y
            if sector_x == 0:  # Лицо слева
                ser.write(b'R')
            elif sector_x == 2:  # Лицо справа
                ser.write(b'L')
            elif sector_y == 0:  # Лицо сверху
                ser.write(b'D')
            elif sector_y == 2:  # Лицо снизу
                ser.write(b'U')
            else:  # Лицо в центре
                ser.write(b'C')
        else:
            # Проверяем, прошло ли 30 секунд с последнего обнаружения лица
            current_time = time.time()
            if current_time - last_face_detected_time > FACE_TIMEOUT:
                # Отправляем команду возврата в центр
                ser.write(b'B')
                print("Отправлена команда возврата в центр (лицо не обнаружено 30 секунд)")

        # Рисуем сетку (для визуализации секторов)
        for i in range(1, 3):
            cv2.line(img, (i * FRAME_WIDTH // 3, 0), (i * FRAME_WIDTH // 3, FRAME_HEIGHT), (255, 0, 0), 1)
            cv2.line(img, (0, i * FRAME_HEIGHT // 3), (FRAME_WIDTH, i * FRAME_HEIGHT // 3), (255, 0, 0), 1)
        
        # Показываем изображение
        cv2.imshow("Face Tracking", img)
        
        # Управление FPS
        elapsed_time = time.time() - start_time
        time_to_wait = FRAME_DELAY - elapsed_time
        if time_to_wait > 0:
            time.sleep(time_to_wait)
        
        if cv2.waitKey(1) & 0xFF == ord('q'):
            break

except KeyboardInterrupt:
    print("\nПрограмма остановлена пользователем")
finally:
    cap.release()
    ser.close()
    cv2.destroyAllWindows()
    print("Ресурсы освобождены")